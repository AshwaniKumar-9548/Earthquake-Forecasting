# ==============================================================
# EARTHQUAKE PREDICTION PROJECT (California) - MCA DATA SCIENCE
# ==============================================================

# --- Importing Libraries ---
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

from statsmodels.tsa.arima.model import ARIMA
from prophet import Prophet
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import pmdarima as pm
import statsmodels.api as sm
from sklearn.metrics import mean_squared_error, mean_absolute_error

# ==============================================================
# 1. Load and Inspect Data
# ==============================================================

df = pd.read_csv(r"C:\Users\akpan\Downloads\combined_eq_california_clean.csv")
print(df.shape)
print(df.columns)
print(df.head())
print(df.dtypes)

# Column names
dt_col = 'time'     # Date column
mag_col = 'mag'     # Magnitude column

# ==============================================================
# 2. Convert Datetime and Clean Data
# ==============================================================

df[dt_col] = pd.to_datetime(df[dt_col], errors='coerce')
df = df.dropna(subset=[dt_col, mag_col]).sort_values(dt_col)
print(df.head())

# ==============================================================
# 3. Filter California Data
# ==============================================================

if 'place' in df.columns:
    df_ca = df[df['place'].str.contains("California", case=False, na=False)].copy()
else:
    df_ca = df[(df['latitude'].between(32, 42)) & (df['longitude'].between(-125, -114))].copy()

print(df.head())

# ==============================================================
# 4. Monthly Aggregation
# ==============================================================

df_ca['month'] = df_ca[dt_col].dt.to_period('M').dt.to_timestamp()

monthly_mean_mag = df_ca.groupby('month')[mag_col].mean().rename("mean_mag")
monthly_count = df_ca.groupby('month').size().rename("count")

ts = pd.concat([monthly_mean_mag, monthly_count], axis=1)
ts = ts.asfreq('MS')                  # Regular monthly frequency
ts['mean_mag'] = ts['mean_mag'].interpolate()  # Fill missing months
ts.head()

# ==============================================================
# 5. Data Visualization
# ==============================================================

plt.figure(figsize=(12, 4))
plt.plot(ts.index, ts['mean_mag'])
plt.title("California: Monthly Mean Magnitude")
plt.xlabel("Date")
plt.ylabel("Mean Magnitude")
plt.show()

plt.figure(figsize=(12, 4))
plt.plot(ts.index, ts['count'])
plt.title("California: Monthly Earthquake Counts")
plt.xlabel("Date")
plt.ylabel("Counts")
plt.show()

# ==============================================================
# 6. Train-Test Split
# ==============================================================

if len(ts) >= 36:
    TEST_MONTHS = 24
else:
    TEST_MONTHS = max(1, int(len(ts) * 0.2))

train = ts.iloc[:-TEST_MONTHS]
test  = ts.iloc[-TEST_MONTHS:]
print("Train months:", len(train), "Test months:", len(test))

# ==============================================================
# 10. AUTO ARIMA (Seasonal) + Evaluation + Visualization
# ==============================================================

import pmdarima as pm
from sklearn.metrics import mean_squared_error
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# --- Fit Auto ARIMA Model ---
smodel = pm.auto_arima(
    train['mean_mag'].dropna(),
    seasonal=True, m=12,
    start_p=0, start_q=0, max_p=5, max_q=5,
    start_P=0, start_Q=0, max_P=2, max_Q=2,
    trace=True, error_action='ignore', suppress_warnings=True
)

print("\nBest Model Summary:")
print(smodel.summary())

# --- Forecast ---
n_steps = len(test)
arima_fc = smodel.predict(n_periods=n_steps)
arima_index = test.index[:n_steps]
auto_arima_pred = pd.Series(arima_fc, index=arima_index, name='auto_arima_pred')

# --- Evaluation Metrics ---
mse_auto = mean_squared_error(test['mean_mag'], auto_arima_pred)
rmse_auto = np.sqrt(mse_auto)

print(f"\nAuto ARIMA Evaluation:")
print(f"MSE: {mse_auto:.4f}")
print(f"RMSE: {rmse_auto:.4f}")

# --- Plot Forecast vs Actual ---
plt.figure(figsize=(12, 6))
plt.plot(train.index, train['mean_mag'], label='Training Data', color='blue')
plt.plot(test.index, test['mean_mag'], label='Actual Test Data', color='black', marker='o')
plt.plot(auto_arima_pred.index, auto_arima_pred.values, label='Auto ARIMA Prediction', color='red', marker='x')

plt.title('Auto ARIMA Forecast vs Actual')
plt.xlabel('Date')
plt.ylabel('Mean Magnitude')
plt.legend()
plt.grid(True)
plt.show()

# --- Plot Residuals ---
residuals = test['mean_mag'] - auto_arima_pred
plt.figure(figsize=(10, 4))
plt.plot(residuals, color='orange')
plt.title('Auto ARIMA Residuals (Error over Time)')
plt.xlabel('Date')
plt.ylabel('Residual (Actual - Predicted)')
plt.grid(True)
plt.show()

# --- Optional: Residual Distribution ---
plt.figure(figsize=(6, 4))
plt.hist(residuals, bins=15, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()
